## 2.1.2 타입 변환
타입 변환은 어떤 타임인 객체를 그와 다른 타입을 기대하는 곳에 사용할 때 자동으로 일어난다.
```c++
bool b = 42; // b는 true
int i = b; // i는 1
i = 3.14; // i는 3
double pi = i; // pi는 3.0
unsigned char c = -1; // 8비트 char이라면 c 값은 255
signed char c2 = 256; // 8비트 char이라면 c2 값은 미정의
```
bool은 true와 false만을 저장하고 0이면 false, 그 이외의 값이면 true이다.

이때 bool은 0이외의 값이면 true이나 보통 1로 저장한다. 그렇기에 i에 1이 저장된다.

부동소수점 값을 정수 타입에 대입하면 소수부를 버리고 정수부만 남는다.

정수 값을 부동소수점 타입에 대입하면 소수부를 0으로 만들고 대입이된다.

비부호화 타입 객체에 범위를 벗어난 값을 대입하면 담을 수 있는 값으로 나머지 연산이 적용된다.

부호화 타입 객체에 범위를 벗어난 값을 대입하면 미정의결과가 나온다. 작동하거나 충돌하거나 쓰레기 값이 남는다.

### 부호 없는 타입을 포함한 표현
의도적이든 아니든 비부호부 타입의 객체를 음수로 만드는 행위를 종종 하곤 한다.
```c++
unsigned u = 10;
int i = -42;
std::cout << i + i << std::endl; //-84
std::cout << i + u << std::endl; // 4294967264
```
int인 i와 unsigned인 u가 +연산자로 계산이 될 때 i의 값이 계산에서만 unsigned형태로 변환된다.

unsigned로 변환되면서 값이 두루마리현상(앞에서 unsigned char에 -1이 255가 되는 현상처럼)이 일어난다.

그래서 값이 의도치 않은 비약적으로 큰 값이 된다.

반복문 같은데에서도 중요하다.
```c++
for(int i = 10; i >= 0; --i;)
std::cout << i << std::endl;
```
여기서 i는 음수가 나올 이유가 없으니 unsigned 형태로 해도 괜찮을거라 생각할 수 있다.

하지만 unsigned는 0보다 작을 수 없기에 조건은 항상 참이 된다.

while문은 먼저 감소시켜 출력할 수 있으므로 가능하다.

### 연습문제
```
2.3 다음 코드에서 출력 결과는 무엇인가?
    unsigned u = 10, u2 = 42;
    std::cout << u2 - u << std::endl;
    std::cout << u - u2 << std::endl;
    int i = 10, i2 = 42;
    std::cout << i2 - i << std::endl;
    std::cout << i - i2 << std::endl;
    std::cout << i - u << std::endl;
    std::cout << u - i << std::endl;
2.4 예상이 맞는지 확인하는 프로그램을 만든다. 예상이 맞지 않으면 문제를 이해할 때까지,
    이 절에서 배운 내용을 다시 학습한다.
```
### 2.3
먼저 예측을 해보자
```unsigned u = 10, u2 = 42;``` unsigned 자료형 변수 2개를 각각 10, 42로 정의 및 초기화 했다.

```std::cout << u2 - u << std::endl;``` 여기서 -연산으로 u가 음수가 되어 언더플로우가 일어났을 것이다.

-u는 약 4,294,967,286정도의 수치일 것이고 여기서 42가 더해지면서 오버플로우가 발생하고 32가 될 것으로 추측된다.

```std::cout << u - u2 << std::endl;``` 아까와 마찬가지로 -연산으로 u2가 음수가 되어 언더플로우가 일어난다.

-u2는 약 4,294,967,251 정도이고 10을 더하면 4,294,967,261로 추측된다.

``` int i = 10, i2 = 42;```int 자료형 변수 2개를 각각 10, 42로 만들었다.

```std::cout << i2 - i << std::endl;``` 은 42 - 10 이므로 32가 나올 것이다.

```std::cout << i - i2 << std::endl;``` 은 10 - 42 이므로 -32가 나올 것이다.

```std::cout << i - u << std::endl;``` 은 10 + 4,294,967,286 이므로 0이 될 것이다.

다시 최대 수치인 4,294,967,295를 넘어 0으로 돌아 갈 것으로 추측

```std::cout << u - i << std::endl;``` 은 은 10 + 4,294,967,286 이므로 0이 될 것이다.

이유는 위와 같다.

### 2.4
```c++
#include <iostream>

int main()
{
    unsigned u = 10, u2 = 42;
    std::cout << u2 - u << std::endl;
    std::cout << u - u2 << std::endl;
    int i = 10, i2 = 42;
    std::cout << i2 - i << std::endl;
    std::cout << i - i2 << std::endl;
    std::cout << i - u << std::endl;
    std::cout << u - i << std::endl;
}
```

__실행결과__
```
32
4294967264
32
-32
0
0
```
언더플로우 시의 자세한 수치는 틀렸지만 전체적으로는 맞았다.

하지만 이걸로는 int형 자료형이 진짜 unsigned자료형과 계산할 때 변하는지 확인할 수 없었다.

그래서 나는 임의의 프로그램을 하나 더 만들어 보았다.

```c++
#include <iostream>

int main()
{
    unsigned u = 0;
    int i = 10, i2 = 42;
    std::cout << u - i << std::endl;
    std::cout << u - i2 << std::endl;
}
```
__실행결과__
```
4294967286
4294967254
```
실제로 계산시 int형 자료형이 unsigned 자료형으로 변화하는 것을 확인했다.
